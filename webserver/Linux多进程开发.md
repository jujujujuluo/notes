

## 进程的创建

```c++
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

**作用**：用于创建子进程

**返回值**：`fork()`返回值会返回两次，一次在父进程中，一次在子进程中

- 在父进程中返回子进程的ID
- 在子进程中返回0

**创建失败的两个原因**：

- 当前系统的进程数已经达到了系统规定的上限，这时`errno`的值被设置为 `EAGAIN`

- 系统内存不足，这时 `errno `的值被设置为 `ENOMEM`

**父子进程的区别**

- `fork()`函数的返回值不同
- `pcb`当中的一切数据
  - 当前进程的id，pid
  - 当前进程的父进程的id，ppid
  - 信号集

**父子进程对于变量是不是共享的？**

- 刚开始的时候是共享的，如果数据修改了就不共享
- 读时共享，写时拷贝

## 父子进程关系及GDB多进程调试

 使用 `GDB `调试的时候，`GDB`默认只能跟踪一个进程，可以在 `fork()` 函数调用之后，通过指令设置 `GDB `调试工具跟踪

 父进程或者子进程，默认跟踪父进程

- 设置调试父进程或者子进程

```c++
set follow-fork-mode [parent(默认)/child]
```

- 设置调试模式 

```c++
set detach-on-fork [on/off]
```

 默认是 `on`，表示调试当前进程的时候，其他进程继续运行；如果为 `off`，调试当前进程的时候，其他进程被 `GDB` 挂起

- 查看调试的进程

```c
info inferiors
```

- 切换当前进程

```c++
inferior id
```

- 使进程脱离 GDB 的调试

```c++
detach inferiors id
```

## exec函数族介绍

- `exec`函数族的作用是根据指定的文件名找到文件，并用它来取代调用过程的内容。换句话说，就是在调用进程内部执行一个可执行文件。
- `exec`函数族的函数执行成功后并不会返回，因为调用进程的实体，包括代码段，数据段和堆栈都已经被新的内容取代，只留下进程ID等表面上的信息仍维持原样。

![image-20240928225521870](C:\Users\juluo\AppData\Roaming\Typora\typora-user-images\image-20240928225521870.png)

## 孤儿进程和僵尸进程

**孤儿进程**：父进程运行结束，但子进程还在运行，这样的子进程就被称为孤儿进程。

- 每当出现一个孤儿进程时，内核就把孤儿进程的父进程设置为`init`，而`init`进程会循环的`wait()`它的已经退出的子进程。这样，当一个孤儿进程凄凉的结束了其生命周期的时候，`init`进程就会处理一切的善后工作
- 因此孤儿进程并不会有什么危害



**僵尸进程**：每个进程结束之后，都会释放自己地址空间的用户区数据，内核区的`PCB`没有办法释放，需要父进程去释放掉。进程终止时，父进程尚未进行释放，子进程残留资源存放在内核中，编程僵尸（Zombie）进程

- 僵尸进程不能被 `kill -9`杀死
- 如果父进程不调用`wait()`或`waitpid()`的话，那么保留的那段信息不会被释放，其进程号就会被一直占用，但是系统能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号导致系统不能产生新的进程，造成危害。



## 进程回收

- 在每个进程退出的时候，内核释放该进程的所有资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）
- 父进程可以通过`wait()`或`waitpid()`得到它的退出状态同时彻底清除这个进程
- `wait()`和`waitpid()`的函数功能一样，区别在于`wait()`函数会阻塞，`waitpid()`可以设置不阻塞，并且可以指定等待哪个子线程结束
- 一次`wait()`或`waitpid()`只能清理一个进程，清理多个子进程应使用循环

